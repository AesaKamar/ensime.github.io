<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Rory Graves and Sam Halliday" />
  <title>ENSIME</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; background-color: #dddddd; }
td.sourceCode { padding-left: 5px; }
code > span.kw { font-weight: bold; } /* Keyword */
code > span.dt { color: #800000; } /* DataType */
code > span.dv { color: #0000ff; } /* DecVal */
code > span.bn { color: #0000ff; } /* BaseN */
code > span.fl { color: #800080; } /* Float */
code > span.ch { color: #ff00ff; } /* Char */
code > span.st { color: #dd0000; } /* String */
code > span.co { color: #808080; font-style: italic; } /* Comment */
code > span.al { color: #00ff00; font-weight: bold; } /* Alert */
code > span.fu { color: #000080; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #ff0000; font-weight: bold; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #ff00ff; } /* SpecialChar */
code > span.vs { color: #dd0000; } /* VerbatimString */
code > span.ss { color: #dd0000; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { } /* Variable */
code > span.cf { } /* ControlFlow */
code > span.op { } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { font-weight: bold; } /* Preprocessor */
code > span.at { } /* Attribute */
code > span.do { color: #808080; font-style: italic; } /* Documentation */
code > span.an { color: #808080; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #808080; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #808080; font-weight: bold; font-style: italic; } /* Information */
  </style>
</head>
<body>
<div id="header">
<h1 class="title">ENSIME</h1>
<h2 class="author">Rory Graves and Sam Halliday</h2>
<h3 class="date"><a href="https://www.parleys.com/tutorial/ensime-why-would-anybody-build-another-scala-ide">Video from Scala Days 2015</a></h3>
</div>
<h1 id="introduction">Introduction</h1>
<div class="notes">
<p>Straw poll -</p>
<ul>
<li>IntelliJ</li>
<li>Eclipse</li>
<li>Emacs/Ensime</li>
<li>Other</li>
</ul>
</div>
<h2 id="rory-graves-a_dev_musing">Rory Graves <code>@a_dev_musing</code><span class="tag" data-tag-name="SAM"></span></h2>
<ul>
<li>Wrote mobile games before it was cool</li>
<li>Dynamic networks before clusters were cool</li>
<li>Shows people around an old windmill at weekends</li>
<li>Martial artist who is a trained swordsman</li>
</ul>
<div class="notes">
<p>Rory was writing mobile games when Nokia Snake was the height of technology, long before it was cool.</p>
<p>He was doing novel research on dynamic network protocols to replace TCP/IP, which was when a cluster was more likely to refer to a collection of peanuts than a collection of server computers.</p>
<p>He shows people around an old windmill in southern England at the weekends.</p>
<p>And he is a black belt in a martial art that I cannot pronounce, with the superpower of sword fighting.</p>
</div>
<hr />
<p><img src="images/compiling.jpg" alt="" /></p>
<div class="notes">
<p>So believe me, you really don’t want to be waiting on your compiler with Rory around!</p>
</div>
<h2 id="sam-halliday-fommil">Sam Halliday <code>@fommil</code><span class="tag" data-tag-name="RORY"></span></h2>
<ul>
<li>co-founded FHSST, 5mil Free textbooks in South Africa</li>
<li>co-founded a mathematics company
<ul>
<li>quantum mechanics, machine learning, etc</li>
</ul></li>
<li>co-founded Neurofiction: brain scanners + fiction</li>
<li><code>netlib-java</code> underpinning Apache Spark</li>
<li>most proud of getting to the Mun in Kerbal…</li>
</ul>
<hr />
<p><img src="images/mun.jpg" alt="" /></p>
<div class="notes">
<p>Free<sub>HighSchoolScienceTexts</sub> No Evidence he ever got back from the Mun</p>
</div>
<h2 id="straw-poll">Straw Poll</h2>
<ul>
<li>IntelliJ</li>
<li>ScalaIDE</li>
<li>Emacs</li>
<li>Other</li>
</ul>
<h2 id="tldr">TL;DR</h2>
<div class="notes">
<ol>
<li>it’s not another IDE, it’s about context</li>
<li>so people can use their favourite text editor</li>
<li>so it can be used programmatically for better tooling / analysis</li>
</ol>
</div>
<ul>
<li>Ensime is not really an IDE</li>
<li>Its a toolset for building IDEs and analysing code.</li>
<li>But…</li>
</ul>
<hr />
<p><img src="images/build_all_the_things.jpg" alt="" /></p>
<p>It is time to build our own IDE!</p>
<h2 id="overview">Overview</h2>
<ul>
<li>Ensime in action</li>
<li>Architecture</li>
<li>Ecosystem - our community</li>
<li>Protocols - Shapeless marshalling magic</li>
<li>The Roadmap</li>
<li>The Future</li>
</ul>
<div class="notes">
<ul>
<li>Ensime in action.</li>
<li>Everything you ever wanted to know about Ensime</li>
<li>Protocol Design
<ul>
<li>Jerk and the power of Shapeless marshalling</li>
</ul></li>
<li>Coming soon</li>
<li>The future</li>
</ul>
<p>End with ‘Demo Time!’</p>
</div>
<h1 id="demo">Demo<span class="tag" data-tag-name="SAM"></span></h1>
<hr />
<iframe id="ensime_youtube" width="560" height="315" src="https://www.youtube.com/embed/H9yUSmTtxdA?rel=0" frameborder="0" allowfullscreen></iframe>

<div class="notes">
<p>(set-frame-font “Inconsolata-24”) (required ’command-log-mode t) (global-command-log-mode) (setq guide-key/guide-key-sequence nil)</p>
<p>sleep 2 ; recordmydesktop –no-sound –on-the-fly-encoding –no-frame -o ensime.ogv</p>
<p>Rough script, for a walkthrough:</p>
<ol>
<li>start with <code>scala-mode2</code> and show regex syntax highlighting.</li>
<li>turn on <code>ensime</code> and comment on the <code>sbt</code> deploy process.</li>
<li>wait for the funny and announce that we’ll have a call for new funnies for the 1.0 release, with a prize for the best.</li>
<li>semantic highlighting kicks in and we can see that everything is correctly detected where regex failed. Until I started using ENSIME for Scala, I always thought the colour coding was a bit random, but now I use colour to help me understand code and I can get a feel for it based on whether its type heavy, data driven or lots of functions.</li>
<li>introduce and error by creating an instance of something that hasn’t been imported. Show the error and then import a suggestion.</li>
<li>Then show the type, and inspect the type.</li>
<li>Come back to the code buffer and autocomplete a method and show the parameter autofill / tab jumping.</li>
<li>Generate / go to the corresponding test</li>
<li>Call out to sbt to run just that test file.</li>
<li>Back to the test file, open up a nearby test file and use it to jump to the implementation.</li>
<li>Pick a class in a third party library and jump to its source code.</li>
<li>Come back, ask for its documentation, view it in your browser. Isn’t it a pity that nobody writes Scaladocs!</li>
<li>Ask for the documentation for something in the Java standard library, read it in the browser.</li>
<li>Rename a local variable or method with refactor.</li>
<li>Reformat the code with Scalariform.</li>
<li>Start a REPL, type some stuff.</li>
<li>Search for a class, show that it works with camel case.</li>
</ol>
</div>
<div class="notes">
<hr />
<video width="1024" height="572" controls>
  <source src="videos/ensime-demo.mp4" type="video/mp4">
Your browser does not support the video tag.
</video>

</div>
<h1 id="architecture">Architecture<span class="tag" data-tag-name="SAM"></span></h1>
<hr />
<p><img src="images/architecture.png" alt="" /></p>
<div class="notes">
<p>This is an architectural overview of the internals of the ensime-server, which is bounded here by the dotted lines.</p>
<p>The text editor communicates with the server via SWANK, which is a bidirectional TCP/IP sockets protocol using S-Expressions as the language. This is really convenient for emacs. We’ll talk about protocols later because we really don’t see ENSIME as being an emacs only library.</p>
<p>The server runs locally, so it also has direct access to the files on the disc and can watch for changes without needing to be told about them. This is typically used for detecting changes in the compiled files rather than looking for changes in source code.</p>
<p>And when the server is started, it needs to be given a <code>.ensime</code> file which defines the project layout. This is typically generated by the build tool.</p>
<p>Inside the server, everything goes via the central Project class which effectively just delegates to the relevant sub-component. The two big parts are the Search Service and the Analyzer:</p>
<ol>
<li>The Search Service indexes all the binaries related to the project, including third party jars. We use ASM to do the heavy lifting and we persist the results to H2 to enable various types of searches. We also build up an index in Lucene for advanced searching, such as camel case searching of a classname.</li>
<li>The Analyzer is our layer that sits on top of the Scala Presentation Compiler, which is an interactive version of the Scala Compiler but is supposed to be quicker because it shortcuts various stages in order to be responsive. This is the same backend that is used by the Scala IDE, but it is released as part of the official Scala Compiler jar.</li>
<li>We also have the ability to identify source code to binaries, e.g. to relate your third party source zip files to the jars that you’re including. This lets us implement the “jump to source” functionality beyond the user’s project files.</li>
<li>Documentation is hosted via a Spray HTTP server and viewed in a normal web browser.</li>
<li>A debug manager component allows interactive debugging sessions against a running JVM. It manages the state of the threads and allows stepping and inspection.</li>
<li>Then there is some stuff that lives on the cusp of what ensime should really do, like source formatting. You can issue a command to ENSIME and it’ll format your sources, which works well if you don’t have automatic formatting as part of your build.</li>
</ol>
<p>We’ve had various discussions about where the “in/out” line should be and we decided that compilation is definitely on the other side of the line because that’s what build tools are designed to do. But with the possibility of closer integration with the new sbt server, we will see the coupling with sbt, in particular, becoming stronger. But we’re not limiting ourselves to one build tool because the reality is that a large number of corporate development environments are using legacy build systems and we want to support that.</p>
</div>
<h1 id="ecosystem">Ecosystem<span class="tag" data-tag-name="SAM"></span></h1>
<h2 id="projects">Projects</h2>
<p><img src="images/projects.png" alt="" /></p>
<div class="notes">
<p>ENSIME isn’t just one project. The server is a Scala project with separate branches to support the three active stable release versions of Scala. (Yes, people are still using Scala 2.9 in production systems).</p>
<p>The compiler API has been quite volatile across versions, so we are not able to offer a single source build. The server jars are published as snapshots to Sonatype, more about that in a few slides.</p>
<p>The emacs client is a completely separate project to the server. It has its own github repository and is published using the emacs package management system MELPA.</p>
<p>Build tool plugins also live in their own repositories. The functionality offered here is typically the ability to generate the <code>.ensime</code> file, although we might see more functionality in the future, for example, integration with the sbt server or automating the debugging launch process with build tool commands. The plugins are rarely updated, so they are published to Maven Central.</p>
<p>And we have a separate repository for creating our docker images, which is used by the build system. We have an official docker image that is used for each release branch and that has all our hard dependencies pre-loaded (i.e. JDK and sbt), this is published to Docker Hub.</p>
</div>
<h2 id="community">Community</h2>
<p><img src="images/leadership.jpg" alt="" /></p>
<p>c.f. <a href="https://www.youtube.com/watch?v=Er1pM9suxvE">Benjamin Mako Hill’s talk at LibrePlanet 2013</a></p>
<div class="notes">
<p><a href="https://www.youtube.com/watch?v=Er1pM9suxvE">Benjamin Mako Hill gave a talk at LibrePlanet 2013</a> did an analysis of projects on github. He showed that the vast majority of projects have one contributor.</p>
<p>ENSIME is a really nice project to work on because it doesn’t have a single owner. Aemon started the project way back in 2010, but myself, Rory and Eric have all been helping out over the last year.</p>
<p>We don’t have a financial backer, so realistic the only way for ENSIME to survive and grow is to have a strong community.</p>
</div>
<h2 id="server-contributors">Server Contributors</h2>
<table>
<thead>
<tr class="header">
<th align="left">Author</th>
<th align="left">+ lines</th>
<th align="left">- lines</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Aemon Cannon</td>
<td align="left">62529</td>
<td align="left">47989</td>
</tr>
<tr class="even">
<td align="left">Sam Halliday</td>
<td align="left">17505</td>
<td align="left">17565</td>
</tr>
<tr class="odd">
<td align="left">Rory Graves</td>
<td align="left">12080</td>
<td align="left">10156</td>
</tr>
<tr class="even">
<td align="left">Eric Daniel</td>
<td align="left">2958</td>
<td align="left">1113</td>
</tr>
<tr class="odd">
<td align="left">Eugene Burmako</td>
<td align="left">413</td>
<td align="left">151</td>
</tr>
<tr class="even">
<td align="left">Jason Fager</td>
<td align="left">230</td>
<td align="left">144</td>
</tr>
<tr class="odd">
<td align="left">Marc Saegesser</td>
<td align="left">160</td>
<td align="left">324</td>
</tr>
<tr class="even">
<td align="left">Fabian</td>
<td align="left">144</td>
<td align="left">45</td>
</tr>
<tr class="odd">
<td align="left">Alexander Pupeikis</td>
<td align="left">126</td>
<td align="left">20</td>
</tr>
<tr class="even">
<td align="left">Jacob Schlather</td>
<td align="left">66</td>
<td align="left">64</td>
</tr>
</tbody>
</table>
<div class="contributors">
<p>Matt Russell, John Sullivan, Daniel Spiewak, Radzisław Galler, Toshiyuki Takahashi, Alexander Baier, Peluko, Grégoire Neuville, Igor Shymko, Anatoly Fayngelerin, tbje, Tomás Senart, Mark Schaake, Marc Weber, Felix Geller, toshiyuki takahashi, sksamuel, pashky, William O’Hanley, Wilfred Springer, The Gitter Badger, Steve Jenson, Scalariform, RayRacine, Pawel Kopiczko, Mike O’Connor, Michael Terry, Jack Viers, Ivan Poliakov, Huw Giddens, Hubert Plociniczak, Habibullah Pagarkar, Evgeny Chukreev, Erik Osheim, Eric Sessoms, Deokhwan Kim, Dave Fayram, Bozhidar Batsov, Bas Kok, Alexandre Bertails, Alejandro Pedraza.</p>
</div>
<div class="notes">
<p>Our list of contributors is really quite large.</p>
<p>These are the authors who have contributed to the <code>ensime-server</code> repository. So there are quite a lot of people, and the vast majority of contributors jump in with a small bugfix or feature.</p>
</div>
<h2 id="emacs-contributors">Emacs Contributors</h2>
<table>
<thead>
<tr class="header">
<th align="left">Author</th>
<th align="left">+ lines</th>
<th align="left">- lines</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Aemon Cannon</td>
<td align="left">30959</td>
<td align="left">15624</td>
</tr>
<tr class="even">
<td align="left">Eric Daniel</td>
<td align="left">16095</td>
<td align="left">15625</td>
</tr>
<tr class="odd">
<td align="left">Sam Halliday</td>
<td align="left">2098</td>
<td align="left">4131</td>
</tr>
<tr class="even">
<td align="left">Radzisław Galler</td>
<td align="left">1094</td>
<td align="left">3183</td>
</tr>
<tr class="odd">
<td align="left">Grégoire Neuville</td>
<td align="left">302</td>
<td align="left">143</td>
</tr>
<tr class="even">
<td align="left">Alexander Pupeikis</td>
<td align="left">132</td>
<td align="left">19</td>
</tr>
<tr class="odd">
<td align="left">Toshiyuki Takahashi</td>
<td align="left">69</td>
<td align="left">62</td>
</tr>
<tr class="even">
<td align="left">Fabian</td>
<td align="left">59</td>
<td align="left">9</td>
</tr>
<tr class="odd">
<td align="left">Alexander Baier</td>
<td align="left">57</td>
<td align="left">58</td>
</tr>
</tbody>
</table>
<div class="contributors">
<p>Robin Green, Łukasz Klich, Paul Sexton, Kirill Kulikov, Erik Assum, Marc Saegesser, ScottyB, Peluko, Eugene Burmako, Matt Russell, Daniel Spiewak, John Sullivan, Jason Fager, Igor Shymko, Anatoly Fayngelerin, tbje, Tyson Hamilton, Tomás Senart, MrBones118, Mark Schaake, Marc Weber, Marc A. Saegesser, Felix Geller, Alejandro Pedraza, toshiyuki takahashi, pdn, pashky, jules, hmgibson23, Wilfred Springer, Sviridov Alexander, Steve Jenson, Scalariform, Sacha Chua, <strong>Rory Graves</strong>, RayRacine, Mike O’Connor, Michael Terry, Jack Viers, Ivan Poliakov, Huw Giddens, Hubert Plociniczak, Howard Branch, Habibullah Pagarkar, Greg Pfeil, Evgeny Chukreev, Erik Osheim, Deokhwan Kim, Dave Fayram, Dave Aitken, Bozhidar Batsov, Ben Spencer, Bas Kok, Andre Silva, Alexandre Bertails.</p>
</div>
<div class="notes">
<p>It’s a similar story with the <code>ensime-emacs</code> repository, but the list of names is quite different.</p>
<p>And note that Rory is way down the list. A little known fact is that he doesn’t actually use Emacs at all!</p>
</div>
<h2 id="community-principles">Community Principles</h2>
<ul>
<li>Code of Conduct
<ul>
<li>good vibes</li>
</ul></li>
<li>Lots of help for new contributors
<ul>
<li>ticket → general area of code</li>
<li>fast PR reviews and feedback</li>
</ul></li>
<li>Pragmatic approach
<ul>
<li>everybody is a Scala dev</li>
<li>KISS: prefer failure / explanation, not complexity</li>
</ul></li>
<li>Bounties!
<ul>
<li>failed experiment</li>
</ul></li>
</ul>
<div class="notes">
<p>Fundamentally, a good community has to be inclusive, share a common goal, and be fun. As admins we try to encourage that vibe with anyone who comes across us and we recently put in place a formal code of conduct. (Selfishly we heard that some people looking for a project to contribute to had said it was a deciding factor for them, so we put one in place… but obviously it’s a good thing to have just in case.)</p>
<p>Typically when we get a bug report, or a feature request, we’ll offer to help the reporter. If you raise a ticket, you can expect to get pointed at the general area in the code that needs improvement and any changes you make will be quickly reviewed. Often with an avalanche of additional suggestions! :-)</p>
<p>This approach obviously doesn’t always work out, and some tickets might never get closed, but clearly it’s working out pretty well because we get a <strong>*lot*</strong> of contributors sending one or two PRs and make an improvement.</p>
<p>We take a pragmatic approach to feature and bugfix prioritisation. It’s not like we’re developing a mass consumer website, or a specialist system with business users — everybody who uses ENSIME is a scala developer and should know how to interpret an exception in the logs. That’s why we prefer <strong>simple</strong> solutions and clear error messages to putting in error handling.</p>
<p>As an example, we recently had a bug report about the server barfing when the config contained a dodgy source zip file. Well, we could write lots of complex code to detect and deal with various kinds of dodgy zipfiles… but we much prefer to throw an exception and then find out how to get the source file excluded in Ivy, and the upstream Nexus. It’s all about doing the simple, often dumb, thing, because that’s easier to maintain.</p>
<p>And we have bounties on a lot of tickets, about $1,000 worth. But nobody wants to claim them even when they close the ticket! What tends to happen is that if someone claims the bounty, they put it back on the project… but we are actually very happy for you to spend it on beer if you’d like! (That was actually the original plan)</p>
</div>
<h2 id="continuous-integration">Continuous Integration</h2>
<p><img src="images/build.png" alt="" /></p>
<div class="notes">
<p>Key to survival of ENSIME is ease of contribution, and the only way to manage that is by automating as much of the development process as possible.</p>
<p>We have a strong emphasis on testing (unit, integration, client tests), coverage, shippable docker images (soon to be replaced by drone).</p>
</div>
<h2 id="continuous-delivery">Continuous Delivery</h2>
<p><img src="images/deploy.png" alt="" /></p>
<div class="notes">
<p>We can do this because of the suite of tests.</p>
<p>Green <code>master</code> builds are automatically deployed to sonatype snapshots repository, and we use <code>sbt</code> in the emacs client to do the deployment on the client machine and obtain the classpath. Every time the client updates, or the user types <code>ensime-update</code> the server deployment will be refreshed.</p>
</div>
<h1 id="protocol">Protocol<span class="tag" data-tag-name="SAM"></span></h1>
<h2 id="greenspuns-tenth-rule">Greenspun’s tenth rule</h2>
<blockquote>
<p>“Any sufficiently complicated program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.”</p>
</blockquote>
<div class="notes">
<p>Yes, ok, so we wrote a lisp interpreter. Actually, we wrote two, but one as emerged as the victor. But it is worth noting that…</p>
</div>
<hr />
<blockquote>
<p>“The class of <strong>sufficiently complicated</strong> programs includes Common Lisp.”</p>
<p>— Robert Morris’ corollary (Y-Combinator)</p>
</blockquote>
<h2 id="s-expressions">S-Expressions</h2>
<p><img src="images/sexp.png" alt="" /></p>
<div class="notes">
<p>Let’s talk about lisp for a little bit, or more specifically, S-Expressions.</p>
<p>For the emacs users among you, this is second nature.</p>
<p>An S-Expression is either an atom - symbol, string, number, array, hashmap, etc - or a cons of two S-Expressions, using this parenthesis notation with a dot to separate the two parts.</p>
</div>
<hr />
<p><img src="images/sexp-list.png" alt="" /></p>
<div class="sourceCode"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(a . (b . (c . <span class="kw">nil</span>)))

(a b c) <span class="co">;; list syntax</span></code></pre></div>
<div class="notes">
<p>One of the most amazing things about S-Expressions, and lisp, is that data is code and code is data.</p>
<p>There is no real “list” data type, in the Scala sense, it’s just any structure that ends with the symbol “nil”.</p>
<p>Lists are so common in lisps that this special syntax is introduced.</p>
</div>
<hr />
<div class="sourceCode"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(:keyA . (valueA . (:keyB . (valueB . <span class="kw">nil</span>))))

(:keyA valueA
 :keyB valueB) <span class="co">;; data syntax with keywords</span>

(:file <span class="st">&quot;Foo.scala&quot;</span>
 :line <span class="dv">13</span>)

<span class="co">;; complex map structure</span>
((<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) <span class="st">&quot;Foo.scala&quot;</span>
 (<span class="kw">:key</span> value) <span class="dv">13</span>)</code></pre></div>
<div class="notes">
<p>And similarly, other collection types are defined by convention rather than with formal types.</p>
<p>Here we have “data syntax”, using keywords - symbols that begin with a colon - which is really just a list of alternating keywords and values.</p>
<p>And here we have a complex map structure where the first key is a list of numbers and the second key is a data structure.</p>
<p>It’s these “data syntax” structures that make up the majority of the ENSIME protocol, called SWANK.</p>
</div>
<h2 id="swank">SWANK</h2>
<ul>
<li>ENSIME derived from SWANK — easy for Emacs</li>
<li>vs JSON
<ul>
<li>JSON keys are <code>String</code></li>
<li>JSON maps are unordered</li>
<li>S-Exp naturally encodes structure</li>
<li>neither has an official schema</li>
</ul></li>
</ul>
<div class="notes">
<p>A little bit of history. Back when Aemon started ENSIME, he was taking inspiration from an emacs mode called SLIME, which is a mode for common lisp. SLIME has an external server that runs a binary that natively understands common lisp, as opposed to emacs lisp, and reports back to emacs using the SWANK protocol. Hence, with all that infrastructure in place on the client side, it made sense to base the ENSIME protocol on the SWANK protocol.</p>
<p>But actually, S-Expressions are pretty amazing as a data format. There is the obvious benefit of fast lisp parsers in existence, but even some shortcomings of JSON can be addressed: JSON keys in a map <strong>must</strong> be <code>String</code> but in S-Expressions they can be arbitrarily complex, and JSON maps are unordered and you cannot be guaranteed that your parser - or the other side - will preserve map ordering — but S-Expressions are fundamentally ordered.</p>
<p>It’s also possible to encode complex structures into S-Expressions, which again can save time… red/black trees and so on are the obvious example.</p>
<p>But as a potential downside - although some may see it as a positive - there is no official schema for either.</p>
</div>
<hr />
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> <span class="fu">TypeAtPointReq</span>(
  file: File,
  range: OffsetRange
) <span class="kw">extends</span> RpcTypeRequest</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> <span class="fu">BasicTypeInfo</span>(
  name: String,
  typeId: Int,
  declAs: DeclaredAs,
  fullName: String,
  typeArgs: Iterable[TypeInfo],
  members: Iterable[EntityInfo],
  pos: Option[SourcePosition],
  outerTypeId: Option[Int]
) <span class="kw">extends</span> TypeInfo</code></pre></div>
<div class="notes">
<p>Let’s take an example of what SWANK actually looks like. Here we have some random case classes that are part of the ENSIME protocol.</p>
</div>
<hr />
<div class="sourceCode"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(:swank-rpc
 (swank:type-at-point
  <span class="st">&quot;&lt;...&gt;/org/ensime/indexer/SearchService.scala&quot;</span>
  <span class="dv">1858</span>)
 <span class="dv">7</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(:return
 (:ok
   (:arrow-type <span class="kw">nil</span>
    <span class="kw">:name</span> <span class="st">&quot;String&quot;</span>
    :type-id <span class="dv">7</span>
    :decl-as <span class="kw">class</span>
    :full-name <span class="st">&quot;java.lang.String&quot;</span>
    :type-args <span class="kw">nil</span>
    :members <span class="kw">nil</span>
    :pos (<span class="kw">:type</span> line
          :file <span class="st">&quot;&lt;...&gt;/java/lang/String.java&quot;</span>
          :line <span class="dv">134</span>)
    :outer-type-id <span class="kw">nil</span>))
 <span class="dv">7</span>)</code></pre></div>
<div class="notes">
<p>And this is what they look like when they are converted into SWANK.</p>
<p>You can see that the client queries with a number for their request, and the server includes that number in the response.</p>
</div>
<h2 id="s-express">S-Express</h2>
<ul>
<li>inspired by <code>spray-json</code>
<ul>
<li>but with shapeless magic for <code>Product</code></li>
</ul></li>
<li>helps automate addition of endpoints
<ul>
<li><strong>makes it easier to contribute features!</strong></li>
<li>but backwards compatibility is limiting</li>
</ul></li>
</ul>
<div class="notes">
<p>So how do we do generate our SWANK? Where does our S-Expression parser live?</p>
<p>It’s actually a completely independent project within the ENSIME codebase called S-Express and you can use it in your own applications. As a tip of the hat to Emacs, it is licensed under the LGPL rather than the Apache License that the rest of ENSIME uses.</p>
<p>The codebase is heavily inspired by spray-json but we use shapeless to reduce boilerplate. In the future we are going to be using shapeless even more heavily — the first cut of S-Express was written before shapeless was up to the task of full serialisation but now it has certainly caught up.</p>
<p>We don’t just use shapeless because it’s a cool thing to do, most importantly, automatic derivation of messages should make it a lot easier for people to contribute to ENSIME itself — which is entirely in keeping with our goal of increasing ENSIME’s chances of survival.</p>
<p>Unfortunately, we’re currently using heavily customised marshalling rules to match the organically grown legacy format, but when we move onto version 2.0 of the protocol (as Rory will discuss) we can dramatically reduce the amount of code and rely more and more on automatic derivation.</p>
</div>
<h1 id="json">JSON<span class="tag" data-tag-name="SAM"></span></h1>
<h2 id="why-json">Why JSON?</h2>
<ul>
<li>Most editors don’t know how to speak Lisp!</li>
<li>If you build it, they will come.</li>
<li>JERK</li>
</ul>
<div class="notes">
<p>We don’t want to be an Emacs only thing. There is lots of interest from people using other editors and, from a purely selfish point of view, I see those users as potential future contributors.</p>
<p>Therefore we have an active pull request in review which adds a JSON protocol to ENSIME, and we went crazy with shapeless. To implement this, we wrote an automatic deriver for entire families of sealed traits and case classes, with as much customisation as anybody would care to shake a stick at.</p>
<p>And we’re calling the protocol JERK, because we’re hilarious like that.</p>
</div>
<h2 id="shapeless">Shapeless</h2>
<ul>
<li><code>HList</code> ⇔ <code>case class</code></li>
<li><code>Coproduct</code> ⇔ <code>sealed trait</code></li>
</ul>
<div class="notes">
<p>The way the deriver works is a whole talk in itself, so I’m going to gloss over most of the details — but I’d be delighted to talk about it if you have any questions over the break or drinks tonight.</p>
<p>To give a crash course in shapeless, what it provides us is the ability to go between a case class and its generic form — an <code>HList</code>. You can think of an HList as being a List where the type of every element is encoded in the type of the list. Therefore a list with 4 elements has 4 types in it.</p>
<p>And shapeless provides the generic form for a sealed family, with Coproduct looking a lot like HList but only one of the elements in actually there for any given instance. I like to about it as an HList of Options where exactly one element is defined.</p>
</div>
<hr />
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">  <span class="kw">implicit</span> <span class="kw">def</span> familyFormat[T](
    <span class="kw">implicit</span>
    gen: LabelledGeneric[T],
    sg: WrappedRootJsonFormat[T, gen.<span class="fu">Repr</span>],
    tpe: Typeable[T]
  ): RootJsonFormat[T] = <span class="kw">new</span> RootJsonFormat[T] {
    <span class="kw">if</span> (log.<span class="fu">isTraceEnabled</span>)
      log.<span class="fu">trace</span>(s<span class="st">&quot;creating ${tpe.describe}&quot;</span>)

    <span class="kw">def</span> <span class="fu">read</span>(j: JsValue): T = gen.<span class="fu">from</span>(sg.<span class="fu">value</span>.<span class="fu">read</span>(j))
    <span class="kw">def</span> <span class="fu">write</span>(t: T): JsObject = sg.<span class="fu">value</span>.<span class="fu">write</span>(gen.<span class="fu">to</span>(t))
  }</code></pre></div>
<div class="notes">
<p>Now, this code doesn’t actually compile due to some compiler constraints that I’ll explain in the next slide, but it is instructive as the “entry point” into the <code>spray-json-shapeless</code> layer.</p>
<p>Basically we define an implicit provider of <code>RootJsonFormat[T]</code> for your <code>T</code>. For your <code>T</code>, if it’s a sealed trait or case class, shapeless will automatically create a <code>LabelledGeneric[T]</code> for us, which allows us to convert into the generic form - an <code>HList</code> or <code>Coproduct</code>.</p>
<p>We also ask shapeless for the <code>Typeable[T]</code>, which simply allows us to print out some debugging information without having to use the reflection API.</p>
<p>And we ask for an implicit <code>WrappedRootJsonFormat[T, gen.Repr]</code>, then all we need to do is to write an implementation of a marshaller for <code>HList</code> and <code>Coproduct</code> — which has type <code>gen.Repr</code> — and that is actually a lot simpler than it sounds but you’ll have to go and read the code to see how we did it.</p>
<p>All we do in read/write is convert to/from the generic representation and call its read/write implementation.</p>
<p>But the compiler doesn’t like two things here:</p>
<ul>
<li>you can’t refer to a type as <code>gen.Repr</code></li>
<li>the order of evaluation of the implicits is a bit funny and sometimes the compiler will try to create this before it creates the <code>WrappedRootJsonFormat</code>.</li>
</ul>
</div>
<h2 id="hipster-aux">Hipster Aux</h2>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">  <span class="kw">implicit</span> <span class="kw">def</span> familyFormat[T, Repr](
    <span class="kw">implicit</span>
    gen: LabelledGeneric.<span class="fu">Aux</span>[T, Repr],
    sg: Lazy[WrappedRootJsonFormat[T, Repr]],
    tpe: Typeable[T]
  ): RootJsonFormat[T] = <span class="kw">new</span> RootJsonFormat[T] {
    <span class="kw">if</span> (log.<span class="fu">isTraceEnabled</span>)
      log.<span class="fu">trace</span>(s<span class="st">&quot;creating ${tpe.describe}&quot;</span>)

    <span class="kw">def</span> <span class="fu">read</span>(j: JsValue): T = gen.<span class="fu">from</span>(sg.<span class="fu">value</span>.<span class="fu">read</span>(j))
    <span class="kw">def</span> <span class="fu">write</span>(t: T): JsObject = sg.<span class="fu">value</span>.<span class="fu">write</span>(gen.<span class="fu">to</span>(t))
  }</code></pre></div>
<div class="notes">
<p>So we have to introduce some hacks.</p>
<p>The first one is known as the <code>Hipster.Aux</code>. Some say that Travis Brown was once called a Hipster Aux as a slur, but he wore it as a badge of honour. Others say that it was an auto-corrector gone mad, who can say the intentions <a href="https://twitter.com/travisbrown/status/344873859910082560">of justy-tylor</a>.</p>
<p>If you see any shapeless code you’ll quickly come across these <code>.Aux</code> types. The reason for their existence is to workaround the compiler limitation that we must declare all the types that we use in the parameter list. So we add an additional free type and then use it in the subsequent code. The <code>LabelledGeneric.Aux</code> places a constraint on <code>Repr</code> and the whole implicit will only trigger when <code>Repr</code> really is the <code>HList</code> or <code>Coproduct</code> for <code>T</code>.</p>
<p>The other hack is to use the <code>Lazy</code> type wrapper around the <code>WrappedRootJsonFormat</code> which is a bit magical but hints to the compiler to try harder at constructing the parameter.</p>
</div>
<hr />
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">  <span class="kw">sealed</span> <span class="kw">trait</span> SimpleTrait
  <span class="kw">case</span> <span class="kw">class</span> <span class="fu">Foo</span>(s: String) <span class="kw">extends</span> SimpleTrait
  <span class="kw">case</span> <span class="kw">class</span> <span class="fu">Bar</span>() <span class="kw">extends</span> SimpleTrait
  <span class="kw">case</span> <span class="kw">object</span> Baz <span class="kw">extends</span> SimpleTrait

  <span class="fu">Foo</span>(<span class="st">&quot;foo&quot;</span>).<span class="fu">toJson</span> <span class="co">// {&quot;type&quot;:&quot;Foo&quot;,&quot;s&quot;:&quot;foo&quot;}</span>
  <span class="fu">Bar</span>().<span class="fu">toJson</span>      <span class="co">// {&quot;type&quot;:&quot;Bar&quot;}</span>
  Baz.<span class="fu">toJson</span>        <span class="co">// {&quot;type&quot;:&quot;Baz&quot;}</span></code></pre></div>
<div class="notes">
<p>Even if you’re not interested in the implementation details, you will be interested in the results. You can define a sealed trait and case class/object family like this</p>
<p>And without writing any marshalling code, you can convert to/from JSON automatically, with all the marshallers being calculated at compile time so it’s <strong>super</strong> fast — almost on par with manually written marshallers.</p>
</div>
<h2 id="compile-times">Compile Times</h2>
<p><img src="images/compiling-consequences.jpg" alt="" /></p>
<div class="notes">
<p>Yeah, but it takes a long time to compile. Which we know is potentially life threatening :-/</p>
<p>We have 50 case classes for our incoming sealed family and it can take 10 minutes to compile this one marshaller. We have a workaround, but it involves a big performance hit to runtime.</p>
<p>So now I’m going to hand over to Rory who has more to say about compiler performance, which is not only relevant for us as ENSIME developers but as ENSIME users — since we fundamentally rely on the compiler for our analysis.</p>
</div>
<h1 id="roadmap">Roadmap<span class="tag" data-tag-name="RORY"></span></h1>
<h2 id="performance">Performance</h2>
<div class="notes">
<p>Mention Miles/YourKit? show performance stats? - probably don’t have time Capture how many objects are created in a single call? Mention possibility of talk?</p>
</div>
<ul>
<li>Ensime is a shim over the presentation compiler</li>
<li>Profiling shows compiler performance is poor in places.</li>
<li>e.g. <code>scala.reflect.internal.Constants.safeToString</code> generates 100s of temporary objects to create a single result string.</li>
<li>Performance is my next primary target</li>
</ul>
<hr />
<h2 id="stable">1.0 Stable</h2>
<div class="notes">
<p>Stability! Some users don’t like the snapshot approach, typically because of corporate proxies, and the possibility of regression. In reality, we’ve been extremely good at not releasing regressions but it would be nice to cut a stable so that we can be more experimental.</p>
</div>
<ul>
<li>Separate stable and bleeding edge releases.</li>
<li>Freedom to break compatibility</li>
<li>JSON/WebSockets — Standard transport layers are A Good Thing™
<ul>
<li><a href="http://doc.akka.io/docs/akka-stream-and-http-experimental/" class="uri">http://doc.akka.io/docs/akka-stream-and-http-experimental/</a></li>
<li><a href="https://github.com/smootoo/simple-spray-websockets/" class="uri">https://github.com/smootoo/simple-spray-websockets/</a></li>
</ul></li>
</ul>
<hr />
<p><img src="images/waffle-1.jpg" alt="" /></p>
<h2 id="simplifications-java">2.0 Simplifications / Java</h2>
<div class="notes">
<p>Dropping support for legacy versions: no more scala-2.9 backport and no more Java 6 support. Better version of Lucene, better filesystem monitoring.</p>
<p>Code quality, we want to make it even easier to add new endpoints to the protocol so we’re going to focus on redesigning the protocol (S-Exp and JSON) to simplify it.</p>
<p>Java support… fear of The Big Java Project looming round the corner that we keep being threatened to be put on by management.</p>
</div>
<p>Whats next?</p>
<ul>
<li>Simplification
<ul>
<li>Core</li>
<li>Protocol</li>
</ul></li>
<li>design for enhancement</li>
<li>Going reactive</li>
<li>Reverse lookup / Find Implementations</li>
<li>Java Support - Enjime</li>
</ul>
<div class="notes">
<p><code>scalac</code> is getting Typed Trees. That’s amazing for ENSIME because it means the presentation compiler could potentially turn into a data structure. It also allows for new debugging paradigms, where branches of the trees can be tracked instead of lines of code.</p>
<p>Also <code>sbt-server</code> is stabilising and we could interface with it to get better feedback from the actual compiler (not the initial stage presentation compiler) and various other project-level events.</p>
</div>
<h1 id="the-future">The future</h1>
<h2 id="more-editors">More editors</h2>
<ul>
<li>Sublime</li>
<li>Atom</li>
<li><del>vi</del> The editor of the beast</li>
<li><em>Your editor here</em></li>
</ul>
<h2 id="atom-demo">Atom Demo</h2>
<p><img src="images/atom_ensime.gif" alt="" /></p>
<p>Viktor Hedefalk</p>
<h2 id="incoming-fire">Incoming fire!</h2>
<ul>
<li>TASTY</li>
<li>Scala.Meta</li>
<li>sbt-remote-control</li>
</ul>
<h2 id="ensime-as-a-toolkit">ENSIME as a toolkit</h2>
<div class="notes">
<p>Could enable lots of new build tools: integrate with scoverage for dead code removal, add return types to public methods (speeds up the compile and makes the code easier to read).</p>
<p>Of course, much of this would be available under a “hint” framework to the editors. Similar in concept to IDE’s hints, but scriptable.</p>
<p>Still a work in progress</p>
</div>
<ul>
<li>A user level API over the compiler
<ul>
<li>Analysis</li>
<li>Tooling
<ul>
<li>Dead code finding and cleanup</li>
<li>Refactoring / Hints</li>
</ul></li>
</ul></li>
</ul>
<h2 id="ensime-ide">Ensime-IDE</h2>
<div class="notes">
<p>IDEs tend to be monolithic - single system - text editors on steroids.</p>
</div>
<ul>
<li>A fundamentally different model
<ul>
<li>IDEs tend to be monolithic</li>
<li>and tied to a legacy model (Java)</li>
</ul></li>
</ul>
<h2 id="how">How?</h2>
<div class="notes">
<p>We are at a nexus - lets change software development the world is changing, development environments hold back fast development (especially in kickstarter style team-building distributed environments).</p>
<p>ScalaJS - Shapeless JSON marshalling on both sides - some kind of voodoo</p>
</div>
<p>Components:</p>
<ul>
<li>Web based front end - Atom/ScalaJS</li>
<li>Shared marshalling code (JERK/Shapeless)</li>
<li>Ensime based Server (Docker deployed)</li>
<li>Nodes to to tasked (sbt-remote/ Docker)
<ul>
<li>Compile</li>
<li>Repl</li>
<li>Testing</li>
<li>Debugging</li>
<li>Coverage</li>
</ul></li>
</ul>
<h2 id="shiny-new-things">Shiny new things</h2>
<div class="notes">
<p>How long does it take to get a project started. Instant setup - first day blues</p>
<p>Isolated dev - project contained in Docker Remote working - local rendering - remote heavy lifting. Scalable platform - compile nodes, test nodes, exec nodes, clusters</p>
</div>
<ul>
<li>Project separation</li>
<li>Remotely hosted development
<ul>
<li>Remote working</li>
</ul></li>
<li>Scalable
<ul>
<li>spin up an entire farm</li>
</ul></li>
</ul>
<h2 id="collaboration">Collaboration</h2>
<div class="notes">
<p>Shared config/setup Shared environment - dual cursors multiple screens Video conference with duel control</p>
</div>
<ul>
<li>Instant setup
<ul>
<li>Setup time - insta-project</li>
<li>training setup time</li>
<li>onboarding</li>
</ul></li>
<li>Instant Collaboration
<ul>
<li>Pairing</li>
</ul></li>
</ul>
<h2 id="other-possibilities">Other possibilities</h2>
<ul>
<li>Scala Playground
<ul>
<li>4scala</li>
</ul></li>
<li>Crowdsourcing</li>
</ul>
<h1 id="final-thoughts">Final thoughts</h1>
<h2 id="final-thoughts-1">Final thoughts</h2>
<ul>
<li>Ensime:
<ul>
<li>is a community project</li>
<li>opens up a bunch of interesting possibilities.</li>
</ul></li>
</ul>
<h2 id="questions">Questions?</h2>
<p>Come join the party!</p>
<p><a href="https://github.com/ensime/ensime-server" class="uri">https://github.com/ensime/ensime-server</a></p>
  <script src="http://code.jquery.com/jquery-1.11.1.min.js" type="text/javascript"></script>
  <script type="text/javascript">
    $("div").hide();
    $("ul").hide();
    $("ol").hide();
    $("span").hide();
    $("pre").hide();
    $("code").hide();
    $("table").hide();
    $("video").hide();
    $("img").hide();
    $("a").hide();
    $("p").hide();
    $("#ensime_youtube").hide();

    $(".notes").show();
    $(".notes").find("*").show();
  </script>
</body>
</html>
